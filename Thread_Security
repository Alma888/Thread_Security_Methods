# Thread_Security_Methods

保证线程安全的两大机制：

    《1》synchronized——监视器锁——monitor lock
    《2》volatile关键字
一、synchronized

1、【语法】：作为方法的一个修饰符；
                   作为代码块出现；synchronized(this){
                                       //具体代码
                                   }

2、【作用】：Java中每个对象中都有一个锁，叫做监视锁(monitor lock)
                执行带synchronized修饰的普通方法时，首先需要lock引用指向的对
                象中的锁。 如果可以锁，就正常执行代码；
                                   否则，需要等其他线程把锁Unlock（解开）。
                如果一个线程lock到了锁，到方法执行结束时，就会unlock这把锁。
3、【关键】：
       <1>、锁在什么地方？
          针对普通方法：锁在调用该方法的引用指向的对象中(this)
       <2>、什么时机加锁，什么时机释放锁？
          释放锁不一定释放CPU

       <3>、锁的持有和释放——线程之间的联系

         每个锁都有自己的lock队列；
         即便不是同一个方法，但只要是指向同一个对象，争抢的就是同一把锁。
         锁虽然在代码块中，但锁的是对象，不是方法。
         没有抢到CPU，就没有资格抢锁。

      <4>、静态同步方法抢的是哪个锁？
           类名.class——类的元对象
           静态同步方法抢的是类的元对象的锁。

      <5>、可以通过代码块控制
        不能对栈里的方法加锁，毫无意义
      <6>、synchronized代码表现
          表格       锁的对象    什么时候加锁   什么时候释放锁
         修饰普通方法  this        进入方法       退出方法
       修饰静态方法    类          进入方法       退出方法
        修饰代码块 小括号引用指向的 进入代码块    退出代码块
                   
     Person.class就是类的对象（反射的知识）

      <7>、synchronized和原子性/可见性/重排序的关系：
           可以保证一定限度的可见性
           下面A先抢占到了锁，所以，A执行的时候，锁上了锁。

加锁和释放锁会伴随着工作内存的刷新，在这个时机，保证了可见性
但，临界区（加-->释放锁之间的代码）的执行中间，不做任何保证

【小总结】：对于原子性、内存可见性、代码的重排序等：理论上，所有的问题都可以用synchronized解决
                                               成本非常大（线程的调度成本非常大）
4、[总结所需复习的]：
         1、语法层面
         2、哪里的锁，什么时候可以保证锁上了（核心）
         3、锁和调度的关系
         4、如何保证原子性/可见性/重排序
         5、缺点

二、volatile关键字 （稍轻量级）

1、【语法】： 修饰变量——变量修饰符，加在定义变量
2、【作用】:  1.可以保证该变量的可见性问题（内存及时刷新）
             2.可以部分保证代码的重排序问题

3、Eg：（volatile可用的）原子性（基本数据类型）：

          改正：long a=10L     不是原子
           volatile long a=10;   是原子
           volatile double a=10;是原子
基本数据类型变量被赋值：
boolean byte short int char float     字面量        是原子
                                                        变量         不是原子      
long double------------------------------任何情况（volatile修饰除外）都不是原
                                                                                                               子
（因为，long类型是64位的，在64位平台的计算机下可以，但是在32为平台下long double 是8字节，64位的，需要两个4字节，所以需要分高32位和低32位，这样就相当于两条指令，所以不具有原子性了）                                          
只有可见性问题，没有原子性问题，所以volatile可以发挥作用。
